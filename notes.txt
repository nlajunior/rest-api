# ambiente

alias python=python3.7

pip install virtualenv

virtualenv ambvir --python=python3.7

Postgresql

apt install postgresql postgresql-contrib

sudo -i -u postgres

psql
\conninfo
\q

exit

sudo -u postgress createuser ubuntu
sudo -u postgress createdb -O ubuntu ubuntu
psql
\password ubuntu
\q

sudo nano /etc/postgresql/10/main/pg_hba.conf
alterar  peer para md5
\q

pip install psycopg2-binary

string de conex√£o 'postgresql://ubuntu:123@localhost:5432/ubuntu'

.bashrc 
export USERDB="admindba"
export PASSWORD="123456789"
export DATABASE="db"
export JWT_SECRET_KEY="T@uT0m&r1@"


from flask_restful import Resource, reqparse
from models.test import TestModel
from flask_jwt_extended import jwt_required
from filtros import *
import mysql.connector


path_params = reqparse.RequestParser()
path_params.add_argument('token', type=str)
path_params.add_argument('fhr_valeu_min', type=float)
path_params.add_argument('fhr_valeu_max', type=float)
path_params.add_argument('limit', type=float)
path_params.add_argument('offset', type=float)

class Tests(Resource):
    def get(self):

        data = path_params.parse_args()
        data_valid = {chave:data[chave] for chave in data if data[chave] is not None}
        parametros= normalize_path_params(**data_valid)

        connection = mysql.connector.connect(user='', password='', host='', database='')

        cursor= cconnection cursor()
        
        if not parametros.get('token'):
            tupla = tuple([parametros[chave] for chave in parametros])
            cursor.execute(query_without_token, tupla)
            result = cursor.fetchall()
        else:
            tupla = tuple([parametros[chave] for chave in parametros])
            cursor.execute(query_with_token, tupla)
            result = cursor.fetchall()

        tests = []
        if result:
           for linha in result:
                tests.append({
                    'id': linha[0],
                    'duration': linha[1],
                    'fhr_valeu': linha[2],
                    'token': linha[3],
                    'date_created':linha[4] ,
                    'device_id': linha[5]
                })

        return {'tests': tests}

        #return {'tests':[test.json() for test in TestModel.query.all()]}

class Test(Resource):
    argumentos = reqparse.RequestParser()
    argumentos.add_argument('duration')
    argumentos.add_argument('fhr_valeu')
    argumentos.add_argument('token', type=str, required=True, help="This field 'token' cannot be left ")
    argumentos.add_argument('date_created')
    argumentos.add_argument('device_id')
   
    def get(self, id):
        test = TestModel.find_test(id)
        if test:
            return test.json()
        return {'message': 'Test not found'}, 404

    @jwt_required
    def  post(self, id):
        if TestModel.find_test(id):
            return {"message": "Test id '{}' already exists.".format(id)}, 400
        
        data = Test.argumentos.parse_args()
        test = TestModel(id, **data)
        try:
            test.save_test()
        except:
            return {'message': 'An internal error ocurred trying to save test'}, 500
        
        return test.json(), 200
    
    @jwt_required
    def put(self, id):
        data = Test.argumentos.parse_args()
                
        test_find = TestModel.find_test(id)
        if test_find:
            test_find.update_test(**data)
            test_find.save_test()
            return test_find.json(), 200

        test = TestModel(id, **data)
        try:
            test.save_test()
        except:
            return {'message': 'An internal error ocurred trying to save test'}, 500
        
        return test, 201

    @jwt_required
    def delete(self, id):
        test = TestModel.find_test(id)
        if test:
            try:
                test.delete_test()
            except:
                return {'message': 'An internal error ocurred trying to delete test'}, 500
            return {'message': 'Test deleted.'}

        return {'message': 'Test not deleted'}, 404